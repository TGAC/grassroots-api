#!/bin/sh
#$RCSfile: gmmpirun_wrapper,v $Revision: 1.14 $Date: 2013/01/10 05:56:02 $

#------------------------------------------------------------------
# Initialization:
# - specify the absolute paths of gm_board_info and mpirun.ch_gm if they are 
# not in $PATH 
# - notify LSF if some ports are not configured in your environment; 
# otherwise, LSF assumes all ports are available to run your jobs.
# - MYRICOM allows no more than 4 cards per host; if your hosts have less, 
# specify the maximum for your system
# - EXIT_VALUE should not be set to 0
#------------------------------------------------------------------

# ---------------------------------------------------------------------
# Clean up all temporary files created by the script.
# ---------------------------------------------------------------------
cleanup_temp_file()
{

    for temp_file in "${TEMP_FILE}" "${GMPI_CONF}" "${TMP_GMPI_PROCFILE}"
    do
        rm -f "${temp_file}" >>$LOGFILE 2>&1
    done
}

# ---------------------------------------------------------------------
# Define the function to handle external signals:
# - display the signal received and the shutdown action to the user
# - log the signal received and the daemon shutdown action
# - exit gracefully by shutting down the daemon
# - set the exit code to 1
# ----------------------------------------------------------------------
#
gmmpirun_exit()
{
    trap '' 1 2 3 15
    echo "Signal Received, Terminating the job<${TMP_JOBID}> and remove temporary files ..."
    echo "Signal Received, Terminating the job<${TMP_JOBID}> and remove temporary files ..." >>$LOGFILE
    cleanup_temp_file
    exit 1
} #gmmpirun_exit

# -----------------------------------------------------
# Source the LSF environment. Optional.
# -----------------------------------------------------
. ${LSF_ENVDIR}/lsf.conf

# -----------------------------------------------------
# Set up the variable LSF_TS representing the TaskStarter.
# -----------------------------------------------------
LSF_TS="$LSF_BINDIR/TaskStarter"

GM_BOARD_INFO_CMD="gm_board_info"
MPIRUN_CMD="mpirun.ch_gm"

EXCLUDE_PORTS="0 1 3" 
MAX_NUM_BOARDS="4"  
LOGFILE="/dev/null"
EXIT_VALUE="66"
TASK_GEOM_OK="0"
RSH_CMD="${LSF_BINDIR}/lsrun -m"

#
# If task geometry is not used 
# Reverse order of the host list to gain better performance
#
if [ -n "$LSB_PJL_TASK_GEOMETRY" ]; then
    REVERSE_ORDER="n"
else
    REVERSE_ORDER="y"
fi

#------------------------------------------------------------------
# Create files with a unique name based on the LSF job ID:
# - log file 
# - machine file 
# - temp file 
#------------------------------------------------------------------
TMP_TMPID=""
if [ -z "$LSB_JOBINDEX" -o "$LSB_JOBINDEX" = "0" ]; then
    TMP_JOBID="$LSB_JOBID"
else
    TMP_JOBID="$LSB_JOBID"_"$LSB_JOBINDEX"
fi

GMPI_CONF=".lsf_${TMP_JOBID}_gmpi.conf"
TEMP_FILE=".lsf_${TMP_JOBID}.tmp"

if [ -d "$HOME" ]; then
    GMPI_CONF="$HOME/$GMPI_CONF"
    TEMP_FILE="$HOME/$TEMP_FILE"
fi

# -----------------------------------------------------
# Use the signal handling function to handle specific external signals.
# ----------------------------------------------------
#
trap gmmpirun_exit 1 2 3 15

#------------------------------------------------------------------
# Find out the current mpich version.
# - if mpirun.ch_gm command has the -machinefile <file> option
# then it's new version (mpich-1.2.4..8+)
# - otherwise, it's the old version
#------------------------------------------------------------------
MPICH_VERSION="old"
rm -f $TEMP_FILE
$MPIRUN_CMD -help 2>$TEMP_FILE
USAGE_OPTION=`grep "\-machinefile" $TEMP_FILE`
if [ "$USAGE_OPTION" != "" ]; then
    MPICH_VERSION="new"
fi

#------------------------------------------------------------------
# Create the machine file: 
# - based on the LSF environment variable LSB_MCPU_HOSTS 
# - verify the myrinet port availability 
# - exit if another job has taken the myrinet port 
# - the format of the machine file depends on the mpich version 
# - the file is used by the mpirun.ch_gm command 
# - the file is used to run the jobs on the hosts selected by LSF
#------------------------------------------------------------------
rm -f $GMPI_CONF
echo "# MPICH-GM machine file created by LSF on `date`" >> $GMPI_CONF

# check if we were able to start writing the conf file
if [ -f $GMPI_CONF ]; then
    :
else
    echo "$0: can't create $GMPI_CONF"
    exit 1
fi

# determine the number of processes and print it to the machine file
TOTAL_NUM_PROC="0"
FLAG=""
for TOKEN in $LSB_MCPU_HOSTS
do
    if [ -z "$FLAG" ]; then
	FLAG="1"
    else
        TOTAL_NUM_PROC=`expr $TOTAL_NUM_PROC + $TOKEN`
        FLAG=""
    fi
done
if [ "$MPICH_VERSION" = "new" ]; then
    echo "# host" >> $GMPI_CONF
else
    echo "$TOTAL_NUM_PROC" >> $GMPI_CONF
    echo "# host     port     board " >> $GMPI_CONF
fi

#
# Reverse LSB_MCPU_HOSTS
#
if [ "$REVERSE_ORDER" = "y" ]; then
    HOST=""
    NEW_LSB_MCPU_HOSTS=""
    for i in $LSB_MCPU_HOSTS
    do
        if [ -z "$HOST" ]
        then
            HOST="$i"
        else
            NEW_LSB_MCPU_HOSTS="$HOST $i $NEW_LSB_MCPU_HOSTS"
            HOST=""
        fi
    done
    LSB_MCPU_HOSTS=$NEW_LSB_MCPU_HOSTS
fi

HOST=""
NUM_PROC=""
FLAG=""
for TOKEN in $LSB_MCPU_HOSTS
do
    if [ -z "$FLAG" ]; then
	HOST="$TOKEN"
	FLAG="1"
    else
        NUM_PROC="$TOKEN"
        FLAG=""
    fi

    if [ -n "$HOST" -a -n "$NUM_PROC" ]; then
	if [ "$MPICH_VERSION" = "new" ]; then
	    echo "$HOST:$NUM_PROC" >> $GMPI_CONF
	else
	    # figure out which port is free and add to GMPI_CONF file
	    NUM_FREE_PORTS="0"
	    BOARD_NUM="0"
	    while [ "$BOARD_NUM" -lt "$MAX_NUM_BOARDS" ]; do
		rm -f $TEMP_FILE
		$RSH_CMD $HOST $GM_BOARD_INFO_CMD -B $BOARD_NUM \
		    > $TEMP_FILE 2>>$LOGFILE 
	 
		# get the number of ports
		# looking for line 'Board has room for n ports' where n is the
		# number of ports
		NUM_PORTS=`grep Board $TEMP_FILE 2>>$LOGFILE \
		    | grep ports 2>>$LOGFILE | awk '{print $5}' 2>>$LOGFILE`
		# looking for header of port status table
		HEADER=`grep Port: $TEMP_FILE 2>>$LOGFILE \
		    | grep Status 2>>$LOGFILE | grep PID 2>>$LOGFILE ` 

		if [ "$NUM_PORTS" != "" -a "$HEADER" != "" ]; then
		    # check which ports are busy/free
		    PORT="0"
		    while [ "$PORT" -lt "$NUM_PORTS" ]; do
			# check for busy ports because gm_board_info
			# doesn't tell us about free ports
			BUSY=`grep $PORT: $TEMP_FILE 2>>$LOGFILE \
			    | grep BUSY 2>>$LOGFILE \
			    | grep gm_board_info 2>>$LOGFILE`

			if [ -n "$BUSY" ]; then
			    # we found the port the gm_board_info used
			    # we can assume this port is free now
			    BUSY=""
			else
			    BUSY=`grep $PORT: $TEMP_FILE 2>>$LOGFILE \
				| grep BUSY 2>>$LOGFILE`
			fi

			# automatically exclude certain ports
			for EXCLUDED in $EXCLUDE_PORTS
			do
			    if [ "$EXCLUDED" = "$PORT" ];then
				BUSY="yes"
			    fi
			done
			    
			if [ -z "$BUSY" ]; then
			    # we have found a free port
			    NUM_FREE_PORTS=`expr $NUM_FREE_PORTS + 1`
			    echo "$HOST     $PORT     $BOARD_NUM" >> $GMPI_CONF

			    if [ "$NUM_FREE_PORTS" -ge "$NUM_PROC" ]; then
				# we have enough ports for this host
				# break out of the two while loops
				break 2
			    fi
			fi

			PORT=`expr $PORT + 1`
		    done
		fi
		BOARD_NUM=`expr $BOARD_NUM + 1`
	    done

	    # make sure we found enough ports, exit if not enough
	    if [ "$NUM_FREE_PORTS" -lt "$NUM_PROC" ]; then
		# not enough
		echo "$0:Required $NUM_PROC ports on $HOST, found $NUM_FREE_PORTS."
#                cleanup_temp_file
		exit $EXIT_VALUE
	    fi
	fi

        # get ready for the next host
	HOST=""
	NUM_PROC=""
    fi
done

# last thing added to GMPI_CONF
echo "# end of file" >> $GMPI_CONF

#  -----------------------------------------------------
#  Process the command line: 
# - extract [mpiopts] from the command line
# - extract jobname [jobopts] from the command line
#  -----------------------------------------------------
ARG00=`$MPIRUN_CMD 2>&1 | \
      egrep '^[[:space:]]+-[[:alpha:]_-]+[[:space:]][[:space:]]' | \
      awk '{printf "%s ", $1}'`
ARG01=`$MPIRUN_CMD 2>&1 | \
      egrep '^[[:space:]]+-[[:alpha:]_-]+[[:space:]][[:alpha:]]' | \
      awk '{printf "%s ", $1}' |sed 's/--gm-shmem-prefix//'`
ARG0="$ARG00$ARG01"
ARG1="`$MPIRUN_CMD 2>&1 | \
      egrep '^[[:space:]]+-[[:alpha:]_-]+[[:space:]]+<[[:alpha:]_[:space:]]+>[[:space:]][[:space:]]'  | \
      awk '{printf "%s ", $1}'`--gm-shmem-prefix"

while [ $# -gt 0 ]
do
     MPIRunOpt="0"

     #single-valued options
     for option in $ARG1
     do
         if [ "$option" = "$1" ]; then  
            MPIRunOpt="1"
	    case "$1" in
	        --gm-np|--gm-f|-machinefile|-np)
		    shift 
		    shift
		    ;;
		-pg)
		    shift
		    GMPI_PROCFILE="$1"
		    shift
		    ;;
	        *)
		    MPICH_GM_OPTS="$MPICH_GM_OPTS $1" #get option name
		    shift 
		    MPICH_GM_OPTS="$MPICH_GM_OPTS $1" #get option value
		    shift
		    ;;
	    esac
            break
        else
            TMPARG=`echo $1 | awk /=/`
            if [ -n "$TMPARG" ]; then
		MPICH_GM_OPTS="$MPICH_GM_OPTS $1" #append to options
		shift
		MPIRunOpt="1"
		break
            fi

         fi
     done

     if [ $MPIRunOpt = "1" ]; then
        : 
     else
        #Non-valued options
        for option in $ARG0
        do
            if [ $option = "$1" ]; then
               MPIRunOpt="1"
               MPICH_GM_OPTS="$MPICH_GM_OPTS $1"
               shift
               break     
            fi
        done
     fi

     if [ $MPIRunOpt = "1" ]; then
        : 
     else 
        JOB_CMDLN="$*"
        break 
     fi

done

# -----------------------------------------------------
#  Set up the CMD_LINE variable representing the integrated section of the command line:
# - LSF_TS, script variable representing the TaskStarter binary. 
#   TaskStarter must start each and every job task process.
# - LSF_TS_OPTIONS, LSF environment variable containing all necessary information 
#   for TaskStarter to callback to LSF's Parallel Application Manager.
# - JOB_CMDLN, script variable containing the job and job options
#--------------------------------------------------------------------------------
if [ -z "$LSF_TS_OPTIONS" ]
then
    echo CMD_LINE="$JOB_CMDLN" >> $LOGFILE
    CMD_LINE="$JOB_CMDLN "
else
    echo CMD_LINE="$LSF_TS $LSF_TS_OPTIONS $JOB_CMDLN" >> $LOGFILE
    CMD_LINE="$LSF_TS $LSF_TS_OPTIONS $JOB_CMDLN "
fi


#------------------------------------------------------------------
# Process $LSB_PJL_TASK_GEOMETRY
# It will shuffle the order the machine_file
# based on the order of task geometry
#------------------------------------------------------------------
TASK_GEOMETRY_ERR=0
if [ -n "$LSB_PJL_TASK_GEOMETRY" ]; then
    . $LSF_BINDIR/pjllib.sh
    if [ "$MPICH_VERSION" = "new" ]; then
        rm -f $GMPI_CONF
        touch $GMPI_CONF
        for token in $LSB_HOSTS
        do
            echo $token >> $GMPI_CONF
        done
    fi

    reorder_file_based_on_task_geom "$GMPI_CONF" "sort"
    TASK_GEOMETRY_ERR="$?"
fi

#------------------------------------------------------------------
# Run the job 
# - use the mpirun.ch_gm command to launch your job
# - you may add other standard mpirun.ch_gm options to the command line
# - for example, to turn on the verbose mode, modify the command line to:
#   $MPIRUN_CMD --gm-f --gm-v $GMPI_CONF $* 
#------------------------------------------------------------------
if [ "$TASK_GEOMETRY_ERR" = "0" ]; then
    if [ "$MPICH_VERSION" = "new" ]; then
#----------------------------------------------------------------------------
# If the procgroup file is present ("-pg procfile" option for mpirun.ch_gm),
# create a new procgroup file containing "$LSF_TS $USER $LSF_TS_OPTIONS" at
# starting from the third field of each line. Ignore empty lines and lines 
# starting with '#'. 
# In other words, user supplied procgroup file of the format:
#   # Comments
#   <empty line>           
#   hostname ntasks a.out [username] [options]
# will be converted into the following procgroup file:
#   hostname ntasks TaskStarter username TaskStarter_options a.out [options]
#-----------------------------------------------------------------------------
	if [ -n "$GMPI_PROCFILE" ]; then
	    TMP_GMPI_PROCFILE="$GMPI_PROCFILE"_${TMP_JOBID}
	    awk -v tsopt="$LSF_TS $USER $LSF_TS_OPTIONS" -v user="$USER" \
	    '{if(NF!= 0&&$1!~/#/){split($0,tmp); \
            printf("%s %s %s ",tmp[1],tmp[2],tsopt); ff=3; \
            if(tmp[ff+1]~user) {printf("%s",tmp[ff]);ff=5} \
            for(i=ff; i<=NF; i++) printf(" %s",tmp[i]);printf("\n")}}' \
	    $GMPI_PROCFILE > $TMP_GMPI_PROCFILE 2>> $LOGFILE
	    echo "   $MPIRUN_CMD -pg $TMP_GMPI_PROCFILE $MPICH_GM_OPTS $CMD_LINE" >> $LOGFILE
	    echo "" >> $LOGFILE
	    echo "Contents of the $TMP_GMPI_PROCFILE procgroup file:" >> $LOGFILE
	    cat $TMP_GMPI_PROCFILE >> $LOGFILE
	    echo "" >> $LOGFILE
	    $MPIRUN_CMD -pg $TMP_GMPI_PROCFILE $MPICH_GM_OPTS $CMD_LINE
	else
	    echo "   $MPIRUN_CMD -np $TOTAL_NUM_PROC -machinefile $GMPI_CONF $MPICH_GM_OPTS $CMD_LINE " >> $LOGFILE
	    $MPIRUN_CMD -np $TOTAL_NUM_PROC -machinefile $GMPI_CONF $MPICH_GM_OPTS $CMD_LINE
	fi
    else
	echo "   $MPIRUN_CMD --gm-f $GMPI_CONF $MPICH_GM_OPTS $CMD_LINE " >> $LOGFILE
	$MPIRUN_CMD --gm-f $GMPI_CONF $MPICH_GM_OPTS $CMD_LINE
    fi
    EXIT_VALUE=$?
fi

#------------------------------------------------------------------
# Clean up:
# - remove temporary files 
# - exit with the exit value of the mpirun.ch_gm command 
#------------------------------------------------------------------
cleanup_temp_file

exit $EXIT_VALUE

#-------------------------------------------------------------------------
# End the script.
#-------------------------------------------------------------------------
